# Syrup: User-Defined Scheduling Across the Stack

原文地址：[doi/10.1145/3477132.3483548](https://dl.acm.org/doi/10.1145/3477132.3483548)

## 背景

1. 应用性能受到多种调度机制的影响，比如 OS 、网络协议栈和应用自身的任务分配
2. 这些调度机制和策略往往与系统自身深度捆绑，例如 Linux 的 CFS 和网卡的流一致哈希 RSS，想要修改调度策略工作量大且通用性差
3. 希望能允许应用跨层定义自己的调度策略，在网卡、协议栈、内核调度器等多个地方执行

用户定义的调度框架需要满足以下需求：

1. 表达力：能够实现多种调度策略
2. 跨层部署：在执行和数据路径上的各个层面生效
3. 低开销
4. 用户隔离

## 设计

Syrup 由以下组件和工作流构成：

1. 调度策略文件，文件内需要实现一个简化的 C 的接口
2. 应用程序通过 `syr_deploy_policy` 调用指定调度策略和 hook
3. 这个函数和守护进程 `syrupd` 通信，后者编译调度策略成可执行代码
4. 将可执行代码部署到调度钩子位置
5. 不同部署点位的调度策略可以通过 `Map` 接口通信

Syrup 将调度抽象为一个在线匹配问题，能够支持网络包、连接、线程作为输入，网卡队列、处理器核和网络 socket 作为执行器。

## 实现

Syrup 利用 eBPF 和 ghOSt 分别作为网络协议栈和内核线程调度的后端，二者均提供了低开销、安全的内核 hook 机制。

## 性能评估

RocksDB 和 MICA ，看 BE 和 LS 负载的吞吐和尾延迟

## 评价

Syrup 在 Linux 内核中不同 hook 机制之上构造了一套统一的跨层调度框架，并且允许不同层和点位的调度执行单元互相通信，应用能够根据自己的情况更好地设计调度策略，并且相对轻松地部署。匹配-执行的抽象在软件定义网络的包调度中应用较广，现在用于 OS 内调度框架应该也很合适。
